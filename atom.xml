<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[NikolaMandic.github.io]]></title>
  <link href="http://NikolaMandic.github.io/atom.xml" rel="self"/>
  <link href="http://NikolaMandic.github.io/"/>
  <updated>2013-10-29T01:03:25+01:00</updated>
  <id>http://NikolaMandic.github.io/</id>
  <author>
    <name><![CDATA[Nikola Mandic]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[CoffeeScript function invocation]]></title>
    <link href="http://NikolaMandic.github.io/blog/2013/10/29/coffeescript-function-invocation/"/>
    <updated>2013-10-29T00:41:00+01:00</updated>
    <id>http://NikolaMandic.github.io/blog/2013/10/29/coffeescript-function-invocation</id>
    <content type="html"><![CDATA[<p>I could not find this in documentation so here is a blog post.   <br/>
Lets say you want to pass an object to a function in CoffeeScript.  <br/>
Like so:</p>

<pre><code>options =
  option1: true
  option5: false

methodCall(options)
</code></pre>

<p>You can also do it like this:</p>

<pre><code>methodCall({option1:true,option5:false})
</code></pre>

<p>or you can do it with out the {}</p>

<pre><code>methodCall(option1:true,option5:false)
</code></pre>

<p>or you can use multiple line</p>

<pre><code>methodCall(
  option1:true,
  option5:false
)
</code></pre>

<p>but what happens if you want to pass two seperate objects like this:</p>

<pre><code>methodCall(object1,object2)    
</code></pre>

<p>you can write</p>

<pre><code>methodCall({option1:true},{option5:false})    
</code></pre>

<p>but you can also use indenation for same effect</p>

<pre><code>methodCall(
  option1:true
    option5:false
)    
</code></pre>

<p>this is an error</p>

<pre><code>methodCall(
option1:true
  option5:false
)    
</code></pre>

<p>but this is not</p>

<pre><code>methodCall(option1:true
option5:false
)    
</code></pre>

<p>the last example is the same as</p>

<pre><code>methodCall({option1:true,option5:true})     
</code></pre>

<p>while</p>

<pre><code>methodCall(option1:true
  option5:false
)
</code></pre>

<p>is equivalet of</p>

<pre><code>methodCall({option1:true},{option5:false})
</code></pre>

<p>So to sum it up  <br/>
indentation level can be used to separate object arguments in CoffeeScript.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[beeScript]]></title>
    <link href="http://NikolaMandic.github.io/blog/2013/10/25/beescript/"/>
    <updated>2013-10-25T15:26:00+02:00</updated>
    <id>http://NikolaMandic.github.io/blog/2013/10/25/beescript</id>
    <content type="html"><![CDATA[<p>In one of my previous posts I wrote about beeScript.
BeeScript is meant to be an automation language for diskotek.
This post is a more detailed description.
Right now it is in early development so this is the description of how it is developed and what state it is in.   <br/>
This is a list of what is currently implemented regarding the communication with the backend:</p>

<ul>
<li><p>reading memory  <br/>
    place=0x80000000  <br/>
    a = memory.place</p></li>
<li><p>sending gdb commands  <br/>
    s ni  <br/>
    s disas /rm $eip-40, $eip+40</p></li>
</ul>


<p>One can use control flow structures, function definitions, variable definitions, expressions.
Some might be developed further.</p>

<p>now the look on the internals of how it all works</p>

<ul>
<li>parser is jison generated and is located in beeScript.jison</li>
<li>interface for code generator is located in compiler.coffee.
it contains bunch of functions that are called when parsers productions are reduced. That class is meant to bee extended
by any code/ast generator.</li>
</ul>


<h3>beeScriptRunner &amp; stack machine vm</h3>

<p>example of one such generator is in beeScriptRunner.coffee. It is a generator for stack machine vm written in coffee script.
The stack machine vm has two stacks.</p>

<ul>
<li>expression stack. Used to calculate and assign stuff  <br/>
    @stack</li>
<li>call stack. Used for method invocation  <br/>
    @callStack</li>
</ul>


<p>variables are stored in</p>

<pre><code>@variables    
</code></pre>

<p>@variables is an object whose properties are variable names</p>

<pre><code>name:{
  name:
  value:
}
</code></pre>

<p>functions are stored in</p>

<pre><code>@functions    
</code></pre>

<p>there is also diskotekLib that is an object containing functions that interface with the backend.
It provides easy extensiblity for the script one can use functions from it by just calling them like functions defined in beeScript.
There is only one argument passed that is ref to expression stack like so.</p>

<pre><code>f(@stack)    
</code></pre>

<p>Parameters are on the stack so one just needs to pop them.  <br/>
Care must be taken to leave the stack in state so that rest of the code works.  <br/>
One would define a function with python like syntax without the : at the end like so</p>

<pre><code>def func(param1, param2)
  param1 = param2

f=func()
</code></pre>

<p>It is important to put that newline at the end of the function. That newline means end of a function. That may be slightly modified.</p>

<p>Arguments are searched first in function block and then global scope. That may change.   <br/>
There are special variables:</p>

<pre><code>memory
eax,ecx,edx,ebx...
</code></pre>

<p>That list may change.   <br/>
Memory special variable can be used for reading from and writing to memory.   <br/>
This is an example of reading:</p>

<pre><code>//create a variable that has an address from where to read memory from
memoryLocation = 0x80000000
//read from memory
contentsOfMemLocation = memory.memoryLocation 
</code></pre>

<p>In the background reading works like cache memory with block access. First it tries to access location if it is not there it asks the backend.
What is returned is a dictionary that looks like this
Then calls access function one more time and gets it.</p>

<p>This is an example of writing:</p>

<pre><code>//create a variable that has an address where we want to write to memory
memoryLocation = 0x80000000
//assemble and write to memory
memory.memoryLocation = 'nop'
</code></pre>

<p>This post may be updated so that it can be used as a reference for the beeScript in the future.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[requirejs module and angularjs]]></title>
    <link href="http://NikolaMandic.github.io/blog/2013/10/22/requirejs-module-and-angularjs/"/>
    <updated>2013-10-22T23:33:00+02:00</updated>
    <id>http://NikolaMandic.github.io/blog/2013/10/22/requirejs-module-and-angularjs</id>
    <content type="html"><![CDATA[<p>here is a way of including requirejs package to be used as angular dependency.</p>

<div><script src='https://gist.github.com/7108545.js'></script>
<noscript><pre><code>'use strict';

//setup module loading
require.config({
    packages:[{
      name:'ace',
      location:'../bower_components/ace/lib/ace',
      main:'ace'
    }]
});
//create wraper service
angular.module('myShinyNewApp').factory('ace', function() {
  var ace={
    ace:null
  };

  require(['ace'],function(_ace){
      ace.ace=_ace;
  });
  return ace;
});

//and now use it for example in a directive

angular.module('ldApp').directive('editor',['ace',function(aceS) {
  var ace = aceS.ace;
  //then it can be used like it would normaly
  var editor = ace.edit(element);

}]);
</code></pre></noscript></div>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[diskotek: second iteration]]></title>
    <link href="http://NikolaMandic.github.io/blog/2013/10/19/diskotek-second-iteration/"/>
    <updated>2013-10-19T18:52:00+02:00</updated>
    <id>http://NikolaMandic.github.io/blog/2013/10/19/diskotek-second-iteration</id>
    <content type="html"><![CDATA[<p>second iteration of diskotek development will be bigger than the first.<br/>
I am currently working on a scripting language called beeScript.
Thought behind beeScript is to have an automation language for the debugger like some modern debuggers have.</p>

<p>Currently it looks something like this(as development goes on it may change):</p>

<pre><code>def doThat()
  variable=5

def doThis()
  variable=3

place = 0x80000000
memory.place = 'nop'
variable = memory.place
if variable == 3
  doThat()
else
  doThis()

while variable
  variable=variable-1
</code></pre>

<p>I plan to add something like this:</p>

<pre><code>memory.headers.elfHeader
fImage.headers.elfHeader
fImage.headers.relocations
</code></pre>

<p>Also plan to integrate Ace editor in main page.<br/>
BeeScript implementation is in CoffeeScript it has compiler in CoffeeScript that produces something
that might be called &ldquo;code&rdquo;, it&rsquo;s a stack of functions.
That generated content is then turned over to simple stack machine runner that runs those functions one by one.</p>

<p>Besides scripting togetherJS is half integrated on page it needs more work.<br/>
x86 support is added.<br/>
It has support for editing of raw bytes when user selects rows and then presses shift+enter. ctrl+enter will open instruction editing that does not work now.
It opens up editbox where one can enter new bytes. If they do not fit it is error.<br/>
That is all located in development branch.</p>
]]></content>
  </entry>
  
</feed>
